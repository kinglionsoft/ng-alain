/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.0.0 (NJsonSchema v9.10.42.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';
import { HttpObserve } from '@angular/common/http/src/client';
import { AuthOptions, DA_OPTIONS_TOKEN } from '@delon/auth';

export class AbpResult<T> {
    success: boolean;
    error: string;
    result: T;
    targetUrl: string;
    unAuthorizedRequest: boolean;
}

@Injectable()
export class AccountClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput): Observable<AbpResult<IsTenantAvailableOutput>> {
        let url_ = '/api/services/app/Account/IsTenantAvailable';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput): Observable<AbpResult<RegisterOutput>> {
        let url_ = '/api/services/app/Account/Register';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Account/SendPasswordResetCode';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput): Observable<AbpResult<ResetPasswordOutput>> {
        let url_ = '/api/services/app/Account/ResetPassword';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Account/SendEmailActivationLink';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Account/ActivateEmail';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput): Observable<AbpResult<ImpersonateOutput>> {
        let url_ = '/api/services/app/Account/Impersonate';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<AbpResult<ImpersonateOutput>> {
        let url_ = '/api/services/app/Account/BackToImpersonator';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput): Observable<AbpResult<SwitchToLinkedAccountOutput>> {
        let url_ = '/api/services/app/Account/SwitchToLinkedAccount';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class AuditLogClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: Date, endDate: Date, userName: string, serviceName: string, methodName: string, browserInfo: string, hasException: boolean, minExecutionDuration: number, maxExecutionDuration: number, sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<PagedResultDtoOfAuditLogListDto>> {
        let url_ = '/api/services/app/AuditLog/GetAuditLogs?';
        if (startDate !== undefined)
            url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        if (userName !== undefined)
            url_ += 'UserName=' + encodeURIComponent('' + userName) + '&'; 
        if (serviceName !== undefined)
            url_ += 'ServiceName=' + encodeURIComponent('' + serviceName) + '&'; 
        if (methodName !== undefined)
            url_ += 'MethodName=' + encodeURIComponent('' + methodName) + '&'; 
        if (browserInfo !== undefined)
            url_ += 'BrowserInfo=' + encodeURIComponent('' + browserInfo) + '&'; 
        if (hasException !== undefined)
            url_ += 'HasException=' + encodeURIComponent('' + hasException) + '&'; 
        if (minExecutionDuration !== undefined)
            url_ += 'MinExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&'; 
        if (maxExecutionDuration !== undefined)
            url_ += 'MaxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: Date, endDate: Date, userName: string, serviceName: string, methodName: string, browserInfo: string, hasException: boolean, minExecutionDuration: number, maxExecutionDuration: number, sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<FileDto>> {
        let url_ = '/api/services/app/AuditLog/GetAuditLogsToExcel?';
        if (startDate !== undefined)
            url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        if (userName !== undefined)
            url_ += 'UserName=' + encodeURIComponent('' + userName) + '&'; 
        if (serviceName !== undefined)
            url_ += 'ServiceName=' + encodeURIComponent('' + serviceName) + '&'; 
        if (methodName !== undefined)
            url_ += 'MethodName=' + encodeURIComponent('' + methodName) + '&'; 
        if (browserInfo !== undefined)
            url_ += 'BrowserInfo=' + encodeURIComponent('' + browserInfo) + '&'; 
        if (hasException !== undefined)
            url_ += 'HasException=' + encodeURIComponent('' + hasException) + '&'; 
        if (minExecutionDuration !== undefined)
            url_ += 'MinExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&'; 
        if (maxExecutionDuration !== undefined)
            url_ += 'MaxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class CachingClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<AbpResult<ListResultDtoOfCacheDto>> {
        let url_ = '/api/services/app/Caching/GetAllCaches';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Caching/ClearCache';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Caching/ClearAllCaches';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class ChatClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<AbpResult<GetUserChatFriendsWithSettingsOutput>> {
        let url_ = '/api/services/app/Chat/GetUserChatFriendsWithSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @tenantId (optional) 
     * @userId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number, userId: number, minMessageId: number): Observable<AbpResult<ListResultDtoOfChatMessageDto>> {
        let url_ = '/api/services/app/Chat/GetUserChatMessages?';
        if (tenantId !== undefined)
            url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&'; 
        if (userId !== undefined)
            url_ += 'UserId=' + encodeURIComponent('' + userId) + '&'; 
        if (minMessageId !== undefined)
            url_ += 'MinMessageId=' + encodeURIComponent('' + minMessageId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class CommonLookupClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean): Observable<AbpResult<ListResultDtoOfSubscribableEditionComboboxItemDto>> {
        let url_ = '/api/services/app/CommonLookup/GetEditionsForCombobox?';
        if (onlyFreeItems !== undefined)
            url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput): Observable<AbpResult<PagedResultDtoOfNameValueDto>> {
        let url_ = '/api/services/app/CommonLookup/FindUsers';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<AbpResult<GetDefaultEditionNameOutput>> {
        let url_ = '/api/services/app/CommonLookup/GetDefaultEditionName';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class ConfigurationClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Configuration/ChangeUiTheme';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class DemoUiComponentsClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDate(date: Date): Observable<AbpResult<DateToStringOutput>> {
        let url_ = '/api/services/app/DemoUiComponents/SendAndGetDate?';
        if (date !== undefined)
            url_ += 'date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: Date): Observable<AbpResult<DateToStringOutput>> {
        let url_ = '/api/services/app/DemoUiComponents/SendAndGetDateTime?';
        if (date !== undefined)
            url_ += 'date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: Date, endDate: Date): Observable<AbpResult<DateToStringOutput>> {
        let url_ = '/api/services/app/DemoUiComponents/SendAndGetDateRange?';
        if (startDate !== undefined)
            url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string): Observable<AbpResult<NameValueOfString[]>> {
        let url_ = '/api/services/app/DemoUiComponents/GetCountries?';
        if (searchTerm !== undefined)
            url_ += 'searchTerm=' + encodeURIComponent('' + searchTerm) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[]): Observable<AbpResult<NameValueOfString[]>> {
        let url_ = '/api/services/app/DemoUiComponents/SendAndGetSelectedCountries';

        const content_ = selectedCountries;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string): Observable<AbpResult<StringOutput>> {
        let url_ = '/api/services/app/DemoUiComponents/SendAndGetValue?';
        if (input !== undefined)
            url_ += 'input=' + encodeURIComponent('' + input) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class EditionClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getEditions(): Observable<AbpResult<ListResultDtoOfEditionListDto>> {
        let url_ = '/api/services/app/Edition/GetEditions';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number): Observable<AbpResult<GetEditionEditOutput>> {
        let url_ = '/api/services/app/Edition/GetEditionForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Edition/CreateOrUpdateEdition';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteEdition(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Edition/DeleteEdition?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @selectedEditionId (optional) 
     * @addAllItem (optional) 
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number, addAllItem: boolean, onlyFreeItems: boolean): Observable<AbpResult<SubscribableEditionComboboxItemDto[]>> {
        let url_ = '/api/services/app/Edition/GetEditionComboboxItems?';
        if (selectedEditionId !== undefined)
            url_ += 'selectedEditionId=' + encodeURIComponent('' + selectedEditionId) + '&'; 
        if (addAllItem !== undefined)
            url_ += 'addAllItem=' + encodeURIComponent('' + addAllItem) + '&'; 
        if (onlyFreeItems !== undefined)
            url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class FriendshipClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput): Observable<AbpResult<FriendDto>> {
        let url_ = '/api/services/app/Friendship/CreateFriendshipRequest';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput): Observable<AbpResult<FriendDto>> {
        let url_ = '/api/services/app/Friendship/CreateFriendshipRequestByUserName';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Friendship/BlockUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Friendship/UnblockUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Friendship/AcceptFriendshipRequest';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class HostDashboardClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: IncomeStatisticsDateInterval, startDate: Date, endDate: Date): Observable<AbpResult<HostDashboardData>> {
        let url_ = '/api/services/app/HostDashboard/GetDashboardStatisticsData?';
        if (incomeStatisticsDateInterval !== undefined)
            url_ += 'IncomeStatisticsDateInterval=' + encodeURIComponent('' + incomeStatisticsDateInterval) + '&'; 
        if (startDate !== undefined)
            url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: IncomeStatisticsDateInterval2, startDate: Date, endDate: Date): Observable<AbpResult<GetIncomeStatisticsDataOutput>> {
        let url_ = '/api/services/app/HostDashboard/GetIncomeStatistics?';
        if (incomeStatisticsDateInterval !== undefined)
            url_ += 'IncomeStatisticsDateInterval=' + encodeURIComponent('' + incomeStatisticsDateInterval) + '&'; 
        if (startDate !== undefined)
            url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: Date, endDate: Date): Observable<AbpResult<GetEditionTenantStatisticsOutput>> {
        let url_ = '/api/services/app/HostDashboard/GetEditionTenantStatistics?';
        if (startDate !== undefined)
            url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&'; 
        if (endDate !== undefined)
            url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class HostSettingsClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<AbpResult<HostSettingsEditDto>> {
        let url_ = '/api/services/app/HostSettings/GetAllSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/HostSettings/UpdateAllSettings';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/HostSettings/SendTestEmail';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class InstallClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setup(input: InstallDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Install/Setup';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AbpResult<AppSettingsJsonDto>> {
        let url_ = '/api/services/app/Install/GetAppSettingsJson';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<AbpResult<CheckDatabaseOutput>> {
        let url_ = '/api/services/app/Install/CheckDatabase';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class InvoiceClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number): Observable<AbpResult<InvoiceDto>> {
        let url_ = '/api/services/app/Invoice/GetInvoiceInfo?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Invoice/CreateInvoice';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class LanguageClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<AbpResult<GetLanguagesOutput>> {
        let url_ = '/api/services/app/Language/GetLanguages';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number): Observable<AbpResult<GetLanguageForEditOutput>> {
        let url_ = '/api/services/app/Language/GetLanguageForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Language/CreateOrUpdateLanguage';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteLanguage(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Language/DeleteLanguage?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Language/SetDefaultLanguage';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number, skipCount: number, sorting: string, sourceName: string, baseLanguageName: string, targetLanguageName: string, targetValueFilter: string, filterText: string): Observable<AbpResult<PagedResultDtoOfLanguageTextListDto>> {
        let url_ = '/api/services/app/Language/GetLanguageTexts?';
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (sourceName === undefined || sourceName === null)
            throw new Error('The parameter "sourceName" must be defined and cannot be null.');
        else
            url_ += 'SourceName=' + encodeURIComponent('' + sourceName) + '&'; 
        if (baseLanguageName !== undefined)
            url_ += 'BaseLanguageName=' + encodeURIComponent('' + baseLanguageName) + '&'; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error('The parameter "targetLanguageName" must be defined and cannot be null.');
        else
            url_ += 'TargetLanguageName=' + encodeURIComponent('' + targetLanguageName) + '&'; 
        if (targetValueFilter !== undefined)
            url_ += 'TargetValueFilter=' + encodeURIComponent('' + targetValueFilter) + '&'; 
        if (filterText !== undefined)
            url_ += 'FilterText=' + encodeURIComponent('' + filterText) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Language/UpdateLanguageText';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }
}

@Injectable()
export class NotificationClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @state (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: State, maxResultCount: number, skipCount: number): Observable<AbpResult<GetNotificationsOutput>> {
        let url_ = '/api/services/app/Notification/GetUserNotifications?';
        if (state !== undefined)
            url_ += 'State=' + encodeURIComponent('' + state) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Notification/SetAllNotificationsAsRead';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Notification/SetNotificationAsRead';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<AbpResult<GetNotificationSettingsOutput>> {
        let url_ = '/api/services/app/Notification/GetNotificationSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Notification/UpdateNotificationSettings';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }
}

@Injectable()
export class OrganizationUnitClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<AbpResult<ListResultDtoOfOrganizationUnitDto>> {
        let url_ = '/api/services/app/OrganizationUnit/GetOrganizationUnits';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number, sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<PagedResultDtoOfOrganizationUnitUserListDto>> {
        let url_ = '/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput): Observable<AbpResult<OrganizationUnitDto>> {
        let url_ = '/api/services/app/OrganizationUnit/CreateOrganizationUnit';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput): Observable<AbpResult<OrganizationUnitDto>> {
        let url_ = '/api/services/app/OrganizationUnit/UpdateOrganizationUnit';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput): Observable<AbpResult<OrganizationUnitDto>> {
        let url_ = '/api/services/app/OrganizationUnit/MoveOrganizationUnit';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/OrganizationUnit/DeleteOrganizationUnit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @userId (optional) 
     * @organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number, organizationUnitId: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?';
        if (userId !== undefined)
            url_ += 'UserId=' + encodeURIComponent('' + userId) + '&'; 
        if (organizationUnitId !== undefined)
            url_ += 'OrganizationUnitId=' + encodeURIComponent('' + organizationUnitId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput): Observable<AbpResult<PagedResultDtoOfNameValueDto>> {
        let url_ = '/api/services/app/OrganizationUnit/FindUsers';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class PaymentClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number): Observable<AbpResult<PaymentInfoDto>> {
        let url_ = '/api/services/app/Payment/GetPaymentInfo?';
        if (upgradeEditionId !== undefined)
            url_ += 'UpgradeEditionId=' + encodeURIComponent('' + upgradeEditionId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto): Observable<AbpResult<any>> {
        let url_ = '/api/services/app/Payment/CreatePayment';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    executePayment(input: ExecutePaymentDto): Observable<AbpResult<any>> {
        let url_ = '/api/services/app/Payment/ExecutePayment';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<PagedResultDtoOfSubscriptionPaymentListDto>> {
        let url_ = '/api/services/app/Payment/GetPaymentHistory?';
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class PermissionClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<AbpResult<ListResultDtoOfFlatPermissionWithLevelDto>> {
        let url_ = '/api/services/app/Permission/GetAllPermissions';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class ProductServiceClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Get?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @name (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string, sorting: string, skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/GetAll?';
        if (name !== undefined)
            url_ += 'Name=' + encodeURIComponent('' + name) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: ProductCreateDto): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: ProductCreateDto): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/ProductDemo/ProductService/Delete?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }
}

@Injectable()
export class ProfileClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<AbpResult<CurrentUserProfileEditDto>> {
        let url_ = '/api/services/app/Profile/GetCurrentUserProfileForEdit';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/SendVerificationSms';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/VerifySmsCode';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/UpdateCurrentUserProfile';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/ChangePassword';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/UpdateProfilePicture';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<AbpResult<GetPasswordComplexitySettingOutput>> {
        let url_ = '/api/services/app/Profile/GetPasswordComplexitySetting';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<AbpResult<GetProfilePictureOutput>> {
        let url_ = '/api/services/app/Profile/GetProfilePicture';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @profilePictureId (optional) 
     * @userId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string, userId: number, tenantId: number): Observable<AbpResult<GetProfilePictureOutput>> {
        let url_ = '/api/services/app/Profile/GetFriendProfilePictureById?';
        if (profilePictureId !== undefined)
            url_ += 'ProfilePictureId=' + encodeURIComponent('' + profilePictureId) + '&'; 
        if (userId !== undefined)
            url_ += 'UserId=' + encodeURIComponent('' + userId) + '&'; 
        if (tenantId !== undefined)
            url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string): Observable<AbpResult<GetProfilePictureOutput>> {
        let url_ = '/api/services/app/Profile/GetProfilePictureById?';
        if (profilePictureId !== undefined)
            url_ += 'profilePictureId=' + encodeURIComponent('' + profilePictureId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Profile/ChangeLanguage';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class RoleClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: RoleDto): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Role/Delete?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<AbpResult<ListResultDtoOfPermissionDto>> {
        let url_ = '/api/services/app/Role/GetAllPermissions';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Get?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfRoleDto>> {
        let url_ = '/api/services/app/Role/GetAll?';
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @permission (optional) 
     * @return Success
     */
    getRoles(permission: string): Observable<AbpResult<ListResultDtoOfRoleListDto>> {
        let url_ = '/api/services/app/Role/GetRoles?';
        if (permission !== undefined)
            url_ += 'Permission=' + encodeURIComponent('' + permission) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number): Observable<AbpResult<GetRoleForEditOutput>> {
        let url_ = '/api/services/app/Role/GetRoleForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Role/CreateOrUpdateRole';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteRole(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Role/DeleteRole?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }
}

@Injectable()
export class SessionClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<AbpResult<GetCurrentLoginInformationsOutput>> {
        let url_ = '/api/services/app/Session/GetCurrentLoginInformations';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<AbpResult<UpdateUserSignInTokenOutput>> {
        let url_ = '/api/services/app/Session/UpdateUserSignInToken';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }
}

@Injectable()
export class SubscriptionClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?';
        if (upgradeEditionId !== undefined)
            url_ += 'upgradeEditionId=' + encodeURIComponent('' + upgradeEditionId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class TenantClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @filter (optional) 
     * @subscriptionEndDateStart (optional) 
     * @subscriptionEndDateEnd (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @editionIdSpecified (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string, subscriptionEndDateStart: Date, subscriptionEndDateEnd: Date, creationDateStart: Date, creationDateEnd: Date, editionId: number, editionIdSpecified: boolean, sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<PagedResultDtoOfTenantListDto>> {
        let url_ = '/api/services/app/Tenant/GetTenants?';
        if (filter !== undefined)
            url_ += 'Filter=' + encodeURIComponent('' + filter) + '&'; 
        if (subscriptionEndDateStart !== undefined)
            url_ += 'SubscriptionEndDateStart=' + encodeURIComponent(subscriptionEndDateStart ? '' + subscriptionEndDateStart.toJSON() : '') + '&'; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += 'SubscriptionEndDateEnd=' + encodeURIComponent(subscriptionEndDateEnd ? '' + subscriptionEndDateEnd.toJSON() : '') + '&'; 
        if (creationDateStart !== undefined)
            url_ += 'CreationDateStart=' + encodeURIComponent(creationDateStart ? '' + creationDateStart.toJSON() : '') + '&'; 
        if (creationDateEnd !== undefined)
            url_ += 'CreationDateEnd=' + encodeURIComponent(creationDateEnd ? '' + creationDateEnd.toJSON() : '') + '&'; 
        if (editionId !== undefined)
            url_ += 'EditionId=' + encodeURIComponent('' + editionId) + '&'; 
        if (editionIdSpecified !== undefined)
            url_ += 'EditionIdSpecified=' + encodeURIComponent('' + editionIdSpecified) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/CreateTenant';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number): Observable<AbpResult<TenantEditDto>> {
        let url_ = '/api/services/app/Tenant/GetTenantForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/UpdateTenant';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteTenant(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/DeleteTenant?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number): Observable<AbpResult<GetTenantFeaturesEditOutput>> {
        let url_ = '/api/services/app/Tenant/GetTenantFeaturesForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/UpdateTenantFeatures';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/ResetTenantSpecificFeatures';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/UnlockTenantAdmin';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class TenantDashboardClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<AbpResult<GetMemberActivityOutput>> {
        let url_ = '/api/services/app/TenantDashboard/GetMemberActivity';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<AbpResult<GetDashboardDataOutput>> {
        let url_ = '/api/services/app/TenantDashboard/GetDashboardData?';
        if (salesSummaryDatePeriod !== undefined)
            url_ += 'SalesSummaryDatePeriod=' + encodeURIComponent('' + salesSummaryDatePeriod) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod2): Observable<AbpResult<GetSalesSummaryOutput>> {
        let url_ = '/api/services/app/TenantDashboard/GetSalesSummary?';
        if (salesSummaryDatePeriod !== undefined)
            url_ += 'SalesSummaryDatePeriod=' + encodeURIComponent('' + salesSummaryDatePeriod) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getWorldMap(input: any): Observable<AbpResult<GetWorldMapOutput>> {
        let url_ = '/api/services/app/TenantDashboard/GetWorldMap?';
        if (input !== undefined)
            url_ += 'input=' + encodeURIComponent('' + input) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getGeneralStats(input: any): Observable<AbpResult<GetGeneralStatsOutput>> {
        let url_ = '/api/services/app/TenantDashboard/GetGeneralStats?';
        if (input !== undefined)
            url_ += 'input=' + encodeURIComponent('' + input) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class TenantRegistrationClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput): Observable<AbpResult<RegisterTenantOutput>> {
        let url_ = '/api/services/app/TenantRegistration/RegisterTenant';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<AbpResult<EditionsSelectOutput>> {
        let url_ = '/api/services/app/TenantRegistration/GetEditionsForSelect';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number): Observable<AbpResult<EditionSelectDto>> {
        let url_ = '/api/services/app/TenantRegistration/GetEdition?';
        if (editionId !== undefined)
            url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class TenantSettingsClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<AbpResult<TenantSettingsEditDto>> {
        let url_ = '/api/services/app/TenantSettings/GetAllSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/TenantSettings/UpdateAllSettings';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/TenantSettings/ClearLogo';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/TenantSettings/ClearCustomCss';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/TenantSettings/SendTestEmail';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class TimingClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: DefaultTimezoneScope): Observable<AbpResult<ListResultDtoOfNameValueDto>> {
        let url_ = '/api/services/app/Timing/GetTimezones?';
        if (defaultTimezoneScope !== undefined)
            url_ += 'DefaultTimezoneScope=' + encodeURIComponent('' + defaultTimezoneScope) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string): Observable<AbpResult<ComboboxItemDto[]>> {
        let url_ = '/api/services/app/Timing/GetTimezoneComboboxItems?';
        if (selectedTimezoneId !== undefined)
            url_ += 'SelectedTimezoneId=' + encodeURIComponent('' + selectedTimezoneId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class TokenAuthClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel): Observable<AbpResult<AuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/Authenticate';

        const content_ = model;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel): Observable<AbpResult<void>> {
        let url_ = '/api/TokenAuth/SendTwoFactorAuthCode';

        const content_ = model;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string): Observable<AbpResult<ImpersonatedAuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/ImpersonatedAuthenticate?';
        if (impersonationToken !== undefined)
            url_ += 'impersonationToken=' + encodeURIComponent('' + impersonationToken) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string): Observable<AbpResult<SwitchedAccountAuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/LinkedAccountAuthenticate?';
        if (switchAccountToken !== undefined)
            url_ += 'switchAccountToken=' + encodeURIComponent('' + switchAccountToken) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<AbpResult<ExternalLoginProviderInfoModel[]>> {
        let url_ = '/api/TokenAuth/GetExternalAuthenticationProviders';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel): Observable<AbpResult<ExternalAuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/ExternalAuthenticate';

        const content_ = model;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string, severity: string): Observable<AbpResult<void>> {
        let url_ = '/api/TokenAuth/TestNotification?';
        if (message !== undefined)
            url_ += 'message=' + encodeURIComponent('' + message) + '&'; 
        if (severity !== undefined)
            url_ += 'severity=' + encodeURIComponent('' + severity) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class UiCustomizationSettingsClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<AbpResult<UiCustomizationSettingsEditDto>> {
        let url_ = '/api/services/app/UiCustomizationSettings/GetUiManagementSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: UiCustomizationSettingsEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings';

        const content_ = settings;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: UiCustomizationSettingsEditDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings';

        const content_ = settings;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class UserClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateUserDto): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: UserDto): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/Delete?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<AbpResult<ListResultDtoOfRoleDto>> {
        let url_ = '/api/services/app/User/GetRoles';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/ChangeLanguage';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Get?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfUserDto>> {
        let url_ = '/api/services/app/User/GetAll?';
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @filter (optional) 
     * @permission (optional) 
     * @role (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string, permission: string, role: number, sorting: string, maxResultCount: number, skipCount: number): Observable<AbpResult<PagedResultDtoOfUserListDto>> {
        let url_ = '/api/services/app/User/GetUsers?';
        if (filter !== undefined)
            url_ += 'Filter=' + encodeURIComponent('' + filter) + '&'; 
        if (permission !== undefined)
            url_ += 'Permission=' + encodeURIComponent('' + permission) + '&'; 
        if (role !== undefined)
            url_ += 'Role=' + encodeURIComponent('' + role) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<AbpResult<FileDto>> {
        let url_ = '/api/services/app/User/GetUsersToExcel';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number): Observable<AbpResult<GetUserForEditOutput>> {
        let url_ = '/api/services/app/User/GetUserForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number): Observable<AbpResult<GetUserPermissionsForEditOutput>> {
        let url_ = '/api/services/app/User/GetUserPermissionsForEdit?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/ResetUserSpecificPermissions';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/UpdateUserPermissions';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/CreateOrUpdateUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteUser(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/DeleteUser?';
        if (id !== undefined)
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/UnlockUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class UserLinkClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/UserLink/LinkToUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number, skipCount: number, sorting: string): Observable<AbpResult<PagedResultDtoOfLinkedUserDto>> {
        let url_ = '/api/services/app/UserLink/GetLinkedUsers?';
        if (maxResultCount !== undefined)
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        if (skipCount !== undefined)
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<AbpResult<ListResultDtoOfLinkedUserDto>> {
        let url_ = '/api/services/app/UserLink/GetRecentlyUsedLinkedUsers';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/UserLink/UnlinkUser';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class UserLoginClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<AbpResult<ListResultDtoOfUserLoginAttemptDto>> {
        let url_ = '/api/services/app/UserLogin/GetRecentUserLoginAttempts';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class WebLogClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<AbpResult<GetLatestWebLogsOutput>> {
        let url_ = '/api/services/app/WebLog/GetLatestWebLogs';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<AbpResult<FileDto>> {
        let url_ = '/api/services/app/WebLog/DownloadWebLogs';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class WorkClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @workId (optional) 
     * @followerId (optional) 
     * @return Success
     */
    follow(workId: number, followerId: number): Observable<AbpResult<boolean>> {
        let url_ = '/api/services/desk/Work/Follow?';
        if (workId !== undefined)
            url_ += 'workId=' + encodeURIComponent('' + workId) + '&'; 
        if (followerId !== undefined)
            url_ += 'followerId=' + encodeURIComponent('' + followerId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @workId (optional) 
     * @followerId (optional) 
     * @return Success
     */
    unfollow(workId: number, followerId: number): Observable<AbpResult<boolean>> {
        let url_ = '/api/services/desk/Work/Unfollow?';
        if (workId !== undefined)
            url_ += 'workId=' + encodeURIComponent('' + workId) + '&'; 
        if (followerId !== undefined)
            url_ += 'followerId=' + encodeURIComponent('' + followerId) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: WorkCreateInput): Observable<AbpResult<number>> {
        let url_ = '/api/services/desk/Work/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    finishStep(input: FinishStepInput): Observable<AbpResult<boolean>> {
        let url_ = '/api/services/desk/Work/FinishStep';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state?: IsTenantAvailableOutputState;
    tenantId?: number;
    serverRootAddress?: string;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state?: IsTenantAvailableOutputState;
    tenantId?: number;
    serverRootAddress?: string;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse?: string;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse?: string;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin?: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin?: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId?: number;
    resetCode: string;
    password: string;
    returnUrl?: string;
    singleSignIn?: string;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId?: number;
    resetCode: string;
    password: string;
    returnUrl?: string;
    singleSignIn?: string;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin?: boolean;
    userName?: string;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin?: boolean;
    userName?: string;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId?: number;
    confirmationCode: string;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId?: number;
    confirmationCode: string;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId?: number;
    userId?: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId?: number;
    userId?: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken?: string;
    tenancyName?: string;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken?: string;
    tenancyName?: string;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId?: number;
    targetUserId?: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId?: number;
    targetUserId?: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken?: string;
    tenancyName?: string;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken?: string;
    tenancyName?: string;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount?: number;
    items?: AuditLogListDto[];

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount?: number;
    items?: AuditLogListDto[];
}

export class AuditLogListDto implements IAuditLogListDto {
    userId?: number;
    userName?: string;
    impersonatorTenantId?: number;
    impersonatorUserId?: number;
    serviceName?: string;
    methodName?: string;
    parameters?: string;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string;
    clientName?: string;
    browserInfo?: string;
    exception?: string;
    customData?: string;
    id?: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? new Date(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId?: number;
    userName?: string;
    impersonatorTenantId?: number;
    impersonatorUserId?: number;
    serviceName?: string;
    methodName?: string;
    parameters?: string;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string;
    clientName?: string;
    browserInfo?: string;
    exception?: string;
    customData?: string;
    id?: number;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items?: CacheDto[];

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCacheDto {
    items?: CacheDto[];
}

export class CacheDto implements ICacheDto {
    name?: string;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CacheDto();
        result.init(json);
        return result;
    }
}

export interface ICacheDto {
    name?: string;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id?: string;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id?: string;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime?: Date;
    friends?: FriendDto[];

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? new Date(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime?: Date;
    friends?: FriendDto[];
}

export class FriendDto implements IFriendDto {
    friendUserId?: number;
    friendTenantId?: number;
    friendUserName?: string;
    friendTenancyName?: string;
    friendProfilePictureId?: string;
    unreadMessageCount?: number;
    isOnline?: boolean;
    state?: FriendDtoState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FriendDto();
        result.init(json);
        return result;
    }
}

export interface IFriendDto {
    friendUserId?: number;
    friendTenantId?: number;
    friendUserName?: string;
    friendTenancyName?: string;
    friendProfilePictureId?: string;
    unreadMessageCount?: number;
    isOnline?: boolean;
    state?: FriendDtoState;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items?: ChatMessageDto[];

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items?: ChatMessageDto[];
}

export class ChatMessageDto implements IChatMessageDto {
    userId?: number;
    tenantId?: number;
    targetUserId?: number;
    targetTenantId?: number;
    side?: ChatMessageDtoSide;
    readState?: ChatMessageDtoReadState;
    receiverReadState?: ChatMessageDtoReceiverReadState;
    message?: string;
    creationTime?: Date;
    sharedMessageId?: string;
    id?: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IChatMessageDto {
    userId?: number;
    tenantId?: number;
    targetUserId?: number;
    targetTenantId?: number;
    side?: ChatMessageDtoSide;
    readState?: ChatMessageDtoReadState;
    receiverReadState?: ChatMessageDtoReceiverReadState;
    message?: string;
    creationTime?: Date;
    sharedMessageId?: string;
    id?: number;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId?: number;
    userId?: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(json);
        return result;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId?: number;
    userId?: number;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items?: SubscribableEditionComboboxItemDto[];

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items?: SubscribableEditionComboboxItemDto[];
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree?: boolean;
    value?: string;
    displayText?: string;
    isSelected?: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree?: boolean;
    value?: string;
    displayText?: string;
    isSelected?: boolean;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId?: number;
    maxResultCount?: number;
    skipCount?: number;
    filter?: string;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    tenantId?: number;
    maxResultCount?: number;
    skipCount?: number;
    filter?: string;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount?: number;
    items?: NameValueDto[];

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount?: number;
    items?: NameValueDto[];
}

export class NameValueDto implements INameValueDto {
    name?: string;
    value?: string;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name?: string;
    value?: string;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name?: string;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name?: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString?: string;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DateToStringOutput();
        result.init(json);
        return result;
    }
}

export interface IDateToStringOutput {
    dateString?: string;
}

export class NameValueOfString implements INameValueOfString {
    name?: string;
    value?: string;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NameValueOfString();
        result.init(json);
        return result;
    }
}

export interface INameValueOfString {
    name?: string;
    value?: string;
}

export class StringOutput implements IStringOutput {
    output?: string;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new StringOutput();
        result.init(json);
        return result;
    }
}

export interface IStringOutput {
    output?: string;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items?: EditionListDto[];

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items?: EditionListDto[];
}

export class EditionListDto implements IEditionListDto {
    name?: string;
    displayName?: string;
    creationTime?: Date;
    id?: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name?: string;
    displayName?: string;
    creationTime?: Date;
    id?: number;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition?: EditionEditDto;
    featureValues?: NameValueDto[];
    features?: FlatFeatureDto[];

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition?: EditionEditDto;
    featureValues?: NameValueDto[];
    features?: FlatFeatureDto[];
}

export class EditionEditDto implements IEditionEditDto {
    id?: number;
    displayName: string;
    monthlyPrice?: number;
    annualPrice?: number;
    trialDayCount?: number;
    waitingDayAfterExpire?: number;
    expiringEditionId?: number;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id?: number;
    displayName: string;
    monthlyPrice?: number;
    annualPrice?: number;
    trialDayCount?: number;
    waitingDayAfterExpire?: number;
    expiringEditionId?: number;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    defaultValue?: string;
    inputType?: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    defaultValue?: string;
    inputType?: FeatureInputTypeDto;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name?: string;
    attributes?: { [key: string] : any; };
    validator?: IValueValidator;
    itemSource?: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name?: string;
    attributes?: { [key: string] : any; };
    validator?: IValueValidator;
    itemSource?: LocalizableComboboxItemSourceDto;
}

export class IValueValidator implements IIValueValidator {
    name?: string;
    attributes?: { [key: string] : any; };

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name?: string;
    attributes?: { [key: string] : any; };
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items?: LocalizableComboboxItemDto[];

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items?: LocalizableComboboxItemDto[];
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value?: string;
    displayText?: string;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value?: string;
    displayText?: string;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateOrUpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId?: number;
    tenantId?: number;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestInput {
    userId?: number;
    tenantId?: number;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName?: string;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName?: string;
}

export class BlockUserInput implements IBlockUserInput {
    userId?: number;
    tenantId?: number;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BlockUserInput();
        result.init(json);
        return result;
    }
}

export interface IBlockUserInput {
    userId?: number;
    tenantId?: number;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId?: number;
    tenantId?: number;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnblockUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnblockUserInput {
    userId?: number;
    tenantId?: number;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId?: number;
    tenantId?: number;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AcceptFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId?: number;
    tenantId?: number;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount?: number;
    newSubscriptionAmount?: number;
    dashboardPlaceholder1?: number;
    dashboardPlaceholder2?: number;
    incomeStatistics?: IncomeStastistic[];
    editionStatistics?: TenantEdition[];
    expiringTenants?: ExpiringTenant[];
    recentTenants?: RecentTenant[];
    maxExpiringTenantsShownCount?: number;
    maxRecentTenantsShownCount?: number;
    subscriptionEndAlertDayCount?: number;
    recentTenantsDayCount?: number;
    subscriptionEndDateStart?: Date;
    subscriptionEndDateEnd?: Date;
    tenantCreationStartDate?: Date;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? new Date(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? new Date(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? new Date(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HostDashboardData();
        result.init(json);
        return result;
    }
}

export interface IHostDashboardData {
    newTenantsCount?: number;
    newSubscriptionAmount?: number;
    dashboardPlaceholder1?: number;
    dashboardPlaceholder2?: number;
    incomeStatistics?: IncomeStastistic[];
    editionStatistics?: TenantEdition[];
    expiringTenants?: ExpiringTenant[];
    recentTenants?: RecentTenant[];
    maxExpiringTenantsShownCount?: number;
    maxRecentTenantsShownCount?: number;
    subscriptionEndAlertDayCount?: number;
    recentTenantsDayCount?: number;
    subscriptionEndDateStart?: Date;
    subscriptionEndDateEnd?: Date;
    tenantCreationStartDate?: Date;
}

export class IncomeStastistic implements IIncomeStastistic {
    label?: string;
    date?: Date;
    amount?: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IncomeStastistic();
        result.init(json);
        return result;
    }
}

export interface IIncomeStastistic {
    label?: string;
    date?: Date;
    amount?: number;
}

export class TenantEdition implements ITenantEdition {
    label?: string;
    value?: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantEdition();
        result.init(json);
        return result;
    }
}

export interface ITenantEdition {
    label?: string;
    value?: number;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName?: string;
    remainingDayCount?: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExpiringTenant();
        result.init(json);
        return result;
    }
}

export interface IExpiringTenant {
    tenantName?: string;
    remainingDayCount?: number;
}

export class RecentTenant implements IRecentTenant {
    id?: number;
    name?: string;
    creationTime?: Date;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RecentTenant();
        result.init(json);
        return result;
    }
}

export interface IRecentTenant {
    id?: number;
    name?: string;
    creationTime?: Date;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics?: IncomeStastistic[];

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetIncomeStatisticsDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics?: IncomeStastistic[];
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics?: TenantEdition[];

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetEditionTenantStatisticsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics?: TenantEdition[];
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing?: HostBillingSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing?: HostBillingSettingsEditDto;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone?: string;
    timezoneForComparison?: string;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone?: string;
    timezoneForComparison?: string;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin?: boolean;
    smsVerificationEnabled?: boolean;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin?: boolean;
    smsVerificationEnabled?: boolean;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress?: string;
    defaultFromDisplayName?: string;
    smtpHost?: string;
    smtpPort?: number;
    smtpUserName?: string;
    smtpPassword?: string;
    smtpDomain?: string;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress?: string;
    defaultFromDisplayName?: string;
    smtpHost?: string;
    smtpPort?: number;
    smtpUserName?: string;
    smtpPassword?: string;
    smtpDomain?: string;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration?: boolean;
    isNewRegisteredTenantActiveByDefault?: boolean;
    useCaptchaOnRegistration?: boolean;
    defaultEditionId?: number;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration?: boolean;
    isNewRegisteredTenantActiveByDefault?: boolean;
    useCaptchaOnRegistration?: boolean;
    defaultEditionId?: number;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings?: boolean;
    passwordComplexity?: PasswordComplexitySetting;
    defaultPasswordComplexity?: PasswordComplexitySetting;
    userLockOut?: UserLockOutSettingsEditDto;
    twoFactorLogin?: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings?: boolean;
    passwordComplexity?: PasswordComplexitySetting;
    defaultPasswordComplexity?: PasswordComplexitySetting;
    userLockOut?: UserLockOutSettingsEditDto;
    twoFactorLogin?: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName?: string;
    address?: string;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName?: string;
    address?: string;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit?: boolean;
    requireLowercase?: boolean;
    requireNonAlphanumeric?: boolean;
    requireUppercase?: boolean;
    requiredLength?: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit?: boolean;
    requireLowercase?: boolean;
    requireNonAlphanumeric?: boolean;
    requireUppercase?: boolean;
    requiredLength?: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled?: boolean;
    maxFailedAccessAttemptsBeforeLockout?: number;
    defaultAccountLockoutSeconds?: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled?: boolean;
    maxFailedAccessAttemptsBeforeLockout?: number;
    defaultAccountLockoutSeconds?: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication?: boolean;
    isEnabled?: boolean;
    isEmailProviderEnabled?: boolean;
    isSmsProviderEnabled?: boolean;
    isRememberBrowserEnabled?: boolean;
    isGoogleAuthenticatorEnabled?: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication?: boolean;
    isEnabled?: boolean;
    isEmailProviderEnabled?: boolean;
    isSmsProviderEnabled?: boolean;
    isRememberBrowserEnabled?: boolean;
    isGoogleAuthenticatorEnabled?: boolean;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl?: string;
    defaultLanguage: string;
    smtpSettings?: EmailSettingsEditDto;
    billInfo?: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InstallDto();
        result.init(json);
        return result;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl?: string;
    defaultLanguage: string;
    smtpSettings?: EmailSettingsEditDto;
    billInfo?: HostBillingSettingsEditDto;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    connectionString?: string;
    webSiteUrl?: string;
    serverSiteUrl?: string;
    languages?: NameValue[];

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AppSettingsJsonDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingsJsonDto {
    connectionString?: string;
    webSiteUrl?: string;
    serverSiteUrl?: string;
    languages?: NameValue[];
}

export class NameValue implements INameValue {
    name?: string;
    value?: string;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NameValue();
        result.init(json);
        return result;
    }
}

export interface INameValue {
    name?: string;
    value?: string;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist?: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CheckDatabaseOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist?: boolean;
}

export class InvoiceDto implements IInvoiceDto {
    amount?: number;
    editionDisplayName?: string;
    invoiceNo?: string;
    invoiceDate?: Date;
    tenantLegalName?: string;
    tenantAddress?: string[];
    tenantTaxNo?: string;
    hostLegalName?: string;
    hostAddress?: string[];

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? new Date(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    amount?: number;
    editionDisplayName?: string;
    invoiceNo?: string;
    invoiceDate?: Date;
    tenantLegalName?: string;
    tenantAddress?: string[];
    tenantTaxNo?: string;
    hostLegalName?: string;
    hostAddress?: string[];
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId?: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId?: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName?: string;
    items?: ApplicationLanguageListDto[];

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName?: string;
    items?: ApplicationLanguageListDto[];
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId?: number;
    name?: string;
    displayName?: string;
    icon?: string;
    isDisabled?: boolean;
    isDeleted?: boolean;
    deleterUserId?: number;
    deletionTime?: Date;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationLanguageListDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageListDto {
    tenantId?: number;
    name?: string;
    displayName?: string;
    icon?: string;
    isDisabled?: boolean;
    isDeleted?: boolean;
    deleterUserId?: number;
    deletionTime?: Date;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language?: ApplicationLanguageEditDto;
    languageNames?: ComboboxItemDto[];
    flags?: ComboboxItemDto[];

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language?: ApplicationLanguageEditDto;
    languageNames?: ComboboxItemDto[];
    flags?: ComboboxItemDto[];
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id?: number;
    name: string;
    icon?: string;
    isEnabled?: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationLanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageEditDto {
    id?: number;
    name: string;
    icon?: string;
    isEnabled?: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value?: string;
    displayText?: string;
    isSelected?: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value?: string;
    displayText?: string;
    isSelected?: boolean;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount?: number;
    items?: LanguageTextListDto[];

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount?: number;
    items?: LanguageTextListDto[];
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key?: string;
    baseValue?: string;
    targetValue?: string;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    key?: string;
    baseValue?: string;
    targetValue?: string;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount?: number;
    totalCount?: number;
    items?: UserNotification[];

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    unreadCount?: number;
    totalCount?: number;
    items?: UserNotification[];
}

export class UserNotification implements IUserNotification {
    tenantId?: number;
    userId?: number;
    state?: UserNotificationState;
    notification?: TenantNotification;
    id?: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId?: number;
    userId?: number;
    state?: UserNotificationState;
    notification?: TenantNotification;
    id?: string;
}

export class TenantNotification implements ITenantNotification {
    tenantId?: number;
    notificationName?: string;
    data?: NotificationData;
    entityType?: string;
    entityTypeName?: string;
    entityId?: any;
    severity?: TenantNotificationSeverity;
    creationTime?: Date;
    id?: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            if (data["entityId"]) {
                this.entityId = {};
                for (let key in data["entityId"]) {
                    if (data["entityId"].hasOwnProperty(key))
                        this.entityId[key] = data["entityId"][key];
                }
            }
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        if (this.entityId) {
            data["entityId"] = {};
            for (let key in this.entityId) {
                if (this.entityId.hasOwnProperty(key))
                    data["entityId"][key] = this.entityId[key];
            }
        }
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId?: number;
    notificationName?: string;
    data?: NotificationData;
    entityType?: string;
    entityTypeName?: string;
    entityId?: any;
    severity?: TenantNotificationSeverity;
    creationTime?: Date;
    id?: string;
}

export class NotificationData implements INotificationData {
    type?: string;
    properties?: { [key: string] : any; };

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type?: string;
    properties?: { [key: string] : any; };
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id?: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id?: string;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications?: boolean;
    notifications?: NotificationSubscriptionWithDisplayNameDto[];

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications?: boolean;
    notifications?: NotificationSubscriptionWithDisplayNameDto[];
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName?: string;
    description?: string;
    name: string;
    isSubscribed?: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName?: string;
    description?: string;
    name: string;
    isSubscribed?: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications?: boolean;
    notifications?: NotificationSubscriptionDto[];

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications?: boolean;
    notifications?: NotificationSubscriptionDto[];
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed?: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed?: boolean;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items?: OrganizationUnitDto[];

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items?: OrganizationUnitDto[];
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId?: number;
    code?: string;
    displayName?: string;
    memberCount?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    parentId?: number;
    code?: string;
    displayName?: string;
    memberCount?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount?: number;
    items?: OrganizationUnitUserListDto[];

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount?: number;
    items?: OrganizationUnitUserListDto[];
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    profilePictureId?: string;
    addedTime?: Date;
    id?: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? new Date(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    profilePictureId?: string;
    addedTime?: Date;
    id?: number;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId?: number;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId?: number;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id?: number;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id?: number;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id?: number;
    newParentId?: number;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id?: number;
    newParentId?: number;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds?: number[];
    organizationUnitId?: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds?: number[];
    organizationUnitId?: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId?: number;
    maxResultCount?: number;
    skipCount?: number;
    filter?: string;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId?: number;
    maxResultCount?: number;
    skipCount?: number;
    filter?: string;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition?: EditionSelectDto;
    additionalPrice?: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PaymentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInfoDto {
    edition?: EditionSelectDto;
    additionalPrice?: number;
}

export class EditionSelectDto implements IEditionSelectDto {
    id?: number;
    name?: string;
    displayName?: string;
    expiringEditionId?: number;
    monthlyPrice?: number;
    annualPrice?: number;
    trialDayCount?: number;
    waitingDayAfterExpire?: number;
    isFree?: boolean;
    additionalData?: AdditionalData;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionSelectDto();
        result.init(json);
        return result;
    }
}

export interface IEditionSelectDto {
    id?: number;
    name?: string;
    displayName?: string;
    expiringEditionId?: number;
    monthlyPrice?: number;
    annualPrice?: number;
    trialDayCount?: number;
    waitingDayAfterExpire?: number;
    isFree?: boolean;
    additionalData?: AdditionalData;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId?: number;
    editionPaymentType?: CreatePaymentDtoEditionPaymentType;
    paymentPeriodType?: CreatePaymentDtoPaymentPeriodType;
    subscriptionPaymentGatewayType?: CreatePaymentDtoSubscriptionPaymentGatewayType;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDto {
    editionId?: number;
    editionPaymentType?: CreatePaymentDtoEditionPaymentType;
    paymentPeriodType?: CreatePaymentDtoPaymentPeriodType;
    subscriptionPaymentGatewayType?: CreatePaymentDtoSubscriptionPaymentGatewayType;
}

export class ExecutePaymentDto implements IExecutePaymentDto {
    gateway?: ExecutePaymentDtoGateway;
    editionPaymentType?: ExecutePaymentDtoEditionPaymentType;
    editionId?: number;
    paymentPeriodType?: ExecutePaymentDtoPaymentPeriodType;
    additionalData?: { [key: string] : string; };

    constructor(data?: IExecutePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.editionPaymentType = data["editionPaymentType"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["additionalData"]) {
                this.additionalData = {};
                for (let key in data["additionalData"]) {
                    if (data["additionalData"].hasOwnProperty(key))
                        this.additionalData[key] = data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExecutePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["editionPaymentType"] = this.editionPaymentType;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    data["additionalData"][key] = this.additionalData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExecutePaymentDto();
        result.init(json);
        return result;
    }
}

export interface IExecutePaymentDto {
    gateway?: ExecutePaymentDtoGateway;
    editionPaymentType?: ExecutePaymentDtoEditionPaymentType;
    editionId?: number;
    paymentPeriodType?: ExecutePaymentDtoPaymentPeriodType;
    additionalData?: { [key: string] : string; };
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount?: number;
    items?: SubscriptionPaymentListDto[];

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount?: number;
    items?: SubscriptionPaymentListDto[];
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway?: string;
    amount?: number;
    editionId?: number;
    dayCount?: number;
    paymentPeriodType?: string;
    paymentId?: string;
    payerId?: string;
    status?: string;
    editionDisplayName?: string;
    tenantId?: number;
    invoiceNo?: string;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway?: string;
    amount?: number;
    editionId?: number;
    dayCount?: number;
    paymentPeriodType?: string;
    paymentId?: string;
    payerId?: string;
    status?: string;
    editionDisplayName?: string;
    tenantId?: number;
    invoiceNo?: string;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    creationTime?: Date;
    creatorUserId?: number;
    id?: number;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items?: FlatPermissionWithLevelDto[];

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items?: FlatPermissionWithLevelDto[];
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level?: number;
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    isGrantedByDefault?: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level?: number;
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    isGrantedByDefault?: boolean;
}

export class ProductSummaryDto implements IProductSummaryDto {
    name?: string;
    creationTime?: Date;
    creatorUserId?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    isDeleted?: boolean;
    deletionTime?: Date;
    deleterUserId?: number;
    id?: number;

    constructor(data?: IProductSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.isDeleted = data["isDeleted"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.deleterUserId = data["deleterUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProductSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IProductSummaryDto {
    name?: string;
    creationTime?: Date;
    creatorUserId?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    isDeleted?: boolean;
    deletionTime?: Date;
    deleterUserId?: number;
    id?: number;
}

export class PagedResultDtoOfProductSummaryDto implements IPagedResultDtoOfProductSummaryDto {
    totalCount?: number;
    items?: ProductSummaryDto[];

    constructor(data?: IPagedResultDtoOfProductSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProductSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfProductSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfProductSummaryDto {
    totalCount?: number;
    items?: ProductSummaryDto[];
}

export class ProductCreateDto implements IProductCreateDto {
    name?: string;
    id?: number;

    constructor(data?: IProductCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProductCreateDto();
        result.init(json);
        return result;
    }
}

export interface IProductCreateDto {
    name?: string;
    id?: number;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber?: string;
    isPhoneNumberConfirmed?: boolean;
    timezone?: string;
    qrCodeSetupImageUrl?: string;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber?: string;
    isPhoneNumberConfirmed?: boolean;
    timezone?: string;
    qrCodeSetupImageUrl?: string;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code?: string;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new VerifySmsCodeInputDto();
        result.init(json);
        return result;
    }
}

export interface IVerifySmsCodeInputDto {
    code?: string;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileName: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileName: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting?: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetPasswordComplexitySettingOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting?: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture?: string;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetProfilePictureOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture?: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
    id?: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
    id?: number;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items?: PermissionDto[];

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items?: PermissionDto[];
}

export class PermissionDto implements IPermissionDto {
    name?: string;
    displayName?: string;
    description?: string;
    id?: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name?: string;
    displayName?: string;
    description?: string;
    id?: number;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount?: number;
    items?: RoleDto[];

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount?: number;
    items?: RoleDto[];
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items?: RoleListDto[];

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items?: RoleListDto[];
}

export class RoleListDto implements IRoleListDto {
    name?: string;
    displayName?: string;
    isStatic?: boolean;
    isDefault?: boolean;
    creationTime?: Date;
    id?: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name?: string;
    displayName?: string;
    isStatic?: boolean;
    isDefault?: boolean;
    creationTime?: Date;
    id?: number;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role?: RoleEditDto;
    permissions?: FlatPermissionDto[];
    grantedPermissionNames?: string[];

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role?: RoleEditDto;
    permissions?: FlatPermissionDto[];
    grantedPermissionNames?: string[];
}

export class RoleEditDto implements IRoleEditDto {
    id?: number;
    displayName: string;
    isDefault?: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id?: number;
    displayName: string;
    isDefault?: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    isGrantedByDefault?: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    isGrantedByDefault?: boolean;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user?: UserLoginInfoDto;
    tenant?: TenantLoginInfoDto;
    application?: ApplicationInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user?: UserLoginInfoDto;
    tenant?: TenantLoginInfoDto;
    application?: ApplicationInfoDto;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    profilePictureId?: string;
    id?: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    profilePictureId?: string;
    id?: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName?: string;
    name?: string;
    logoId?: string;
    logoFileType?: string;
    customCssId?: string;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;
    edition?: EditionInfoDto;
    creationTime?: Date;
    paymentPeriodType?: TenantLoginInfoDtoPaymentPeriodType;
    subscriptionDateString?: string;
    creationTimeString?: string;
    id?: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName?: string;
    name?: string;
    logoId?: string;
    logoFileType?: string;
    customCssId?: string;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;
    edition?: EditionInfoDto;
    creationTime?: Date;
    paymentPeriodType?: TenantLoginInfoDtoPaymentPeriodType;
    subscriptionDateString?: string;
    creationTimeString?: string;
    id?: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version?: string;
    releaseDate?: Date;
    features?: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version?: string;
    releaseDate?: Date;
    features?: { [key: string] : boolean; };
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName?: string;
    trialDayCount?: number;
    monthlyPrice?: number;
    annualPrice?: number;
    isHighestEdition?: boolean;
    isFree?: boolean;
    id?: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName?: string;
    trialDayCount?: number;
    monthlyPrice?: number;
    annualPrice?: number;
    isHighestEdition?: boolean;
    isFree?: boolean;
    id?: number;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken?: string;
    encodedUserId?: string;
    encodedTenantId?: string;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken?: string;
    encodedUserId?: string;
    encodedTenantId?: string;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount?: number;
    items?: TenantListDto[];

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount?: number;
    items?: TenantListDto[];
}

export class TenantListDto implements ITenantListDto {
    tenancyName?: string;
    name?: string;
    editionDisplayName?: string;
    connectionString?: string;
    isActive?: boolean;
    creationTime?: Date;
    subscriptionEndDateUtc?: Date;
    editionId?: number;
    isInTrialPeriod?: boolean;
    id?: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName?: string;
    name?: string;
    editionDisplayName?: string;
    connectionString?: string;
    isActive?: boolean;
    creationTime?: Date;
    subscriptionEndDateUtc?: Date;
    editionId?: number;
    isInTrialPeriod?: boolean;
    id?: number;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword?: string;
    connectionString?: string;
    shouldChangePasswordOnNextLogin?: boolean;
    sendActivationEmail?: boolean;
    editionId?: number;
    isActive?: boolean;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword?: string;
    connectionString?: string;
    shouldChangePasswordOnNextLogin?: boolean;
    sendActivationEmail?: boolean;
    editionId?: number;
    isActive?: boolean;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString?: string;
    editionId?: number;
    isActive?: boolean;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;
    id?: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString?: string;
    editionId?: number;
    isActive?: boolean;
    subscriptionEndDateUtc?: Date;
    isInTrialPeriod?: boolean;
    id?: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues?: NameValueDto[];
    features?: FlatFeatureDto[];

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues?: NameValueDto[];
    features?: FlatFeatureDto[];
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id?: number;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id?: number;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id?: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id?: number;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities?: MemberActivity[];

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetMemberActivityOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities?: MemberActivity[];
}

export class MemberActivity implements IMemberActivity {
    name?: string;
    earnings?: string;
    cases?: number;
    closed?: number;
    rate?: string;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MemberActivity();
        result.init(json);
        return result;
    }
}

export interface IMemberActivity {
    name?: string;
    earnings?: string;
    cases?: number;
    closed?: number;
    rate?: string;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit?: number;
    newFeedbacks?: number;
    newOrders?: number;
    newUsers?: number;
    salesSummary?: SalesSummaryData[];
    totalSales?: number;
    revenue?: number;
    expenses?: number;
    growth?: number;
    transactionPercent?: number;
    newVisitPercent?: number;
    bouncePercent?: number;
    dailySales?: number[];
    profitShares?: number[];

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetDashboardDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit?: number;
    newFeedbacks?: number;
    newOrders?: number;
    newUsers?: number;
    salesSummary?: SalesSummaryData[];
    totalSales?: number;
    revenue?: number;
    expenses?: number;
    growth?: number;
    transactionPercent?: number;
    newVisitPercent?: number;
    bouncePercent?: number;
    dailySales?: number[];
    profitShares?: number[];
}

export class SalesSummaryData implements ISalesSummaryData {
    period?: string;
    sales?: number;
    profit?: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SalesSummaryData();
        result.init(json);
        return result;
    }
}

export interface ISalesSummaryData {
    period?: string;
    sales?: number;
    profit?: number;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary?: SalesSummaryData[];

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetSalesSummaryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary?: SalesSummaryData[];
}

export class GetWorldMapOutput implements IGetWorldMapOutput {
    countries?: WorldMapCountry[];

    constructor(data?: IGetWorldMapOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["countries"] && data["countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["countries"])
                    this.countries.push(WorldMapCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWorldMapOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorldMapOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.countries && this.countries.constructor === Array) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetWorldMapOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWorldMapOutput {
    countries?: WorldMapCountry[];
}

export class WorldMapCountry implements IWorldMapCountry {
    countryName?: string;
    color?: number;

    constructor(data?: IWorldMapCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.color = data["color"];
        }
    }

    static fromJS(data: any): WorldMapCountry {
        data = typeof data === 'object' ? data : {};
        let result = new WorldMapCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["color"] = this.color;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WorldMapCountry();
        result.init(json);
        return result;
    }
}

export interface IWorldMapCountry {
    countryName?: string;
    color?: number;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent?: number;
    newVisitPercent?: number;
    bouncePercent?: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetGeneralStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent?: number;
    newVisitPercent?: number;
    bouncePercent?: number;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword?: string;
    captchaResponse?: string;
    subscriptionStartType?: RegisterTenantInputSubscriptionStartType;
    gateway?: RegisterTenantInputGateway;
    editionId?: number;
    paymentId?: string;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.gateway = data["gateway"];
            this.editionId = data["editionId"];
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["gateway"] = this.gateway;
        data["editionId"] = this.editionId;
        data["paymentId"] = this.paymentId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterTenantInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword?: string;
    captchaResponse?: string;
    subscriptionStartType?: RegisterTenantInputSubscriptionStartType;
    gateway?: RegisterTenantInputGateway;
    editionId?: number;
    paymentId?: string;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId?: number;
    tenancyName?: string;
    name?: string;
    userName?: string;
    emailAddress?: string;
    isTenantActive?: boolean;
    isActive?: boolean;
    isEmailConfirmationRequired?: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterTenantOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantOutput {
    tenantId?: number;
    tenancyName?: string;
    name?: string;
    userName?: string;
    emailAddress?: string;
    isTenantActive?: boolean;
    isActive?: boolean;
    isEmailConfirmationRequired?: boolean;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures?: FlatFeatureSelectDto[];
    editionsWithFeatures?: EditionWithFeaturesDto[];
    tenantEditionId?: number;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionsSelectOutput();
        result.init(json);
        return result;
    }
}

export interface IEditionsSelectOutput {
    allFeatures?: FlatFeatureSelectDto[];
    editionsWithFeatures?: EditionWithFeaturesDto[];
    tenantEditionId?: number;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    defaultValue?: string;
    inputType?: IInputType;
    textHtmlColor?: string;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FlatFeatureSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureSelectDto {
    parentName?: string;
    name?: string;
    displayName?: string;
    description?: string;
    defaultValue?: string;
    inputType?: IInputType;
    textHtmlColor?: string;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition?: EditionSelectDto;
    featureValues?: NameValueDto[];

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EditionWithFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface IEditionWithFeaturesDto {
    edition?: EditionSelectDto;
    featureValues?: NameValueDto[];
}

export class IInputType implements IIInputType {
    name?: string;
    attributes?: { [key: string] : any; };
    validator?: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IInputType();
        result.init(json);
        return result;
    }
}

export interface IIInputType {
    name?: string;
    attributes?: { [key: string] : any; };
    validator?: IValueValidator;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general?: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email?: EmailSettingsEditDto;
    ldap?: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing?: TenantBillingSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general?: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email?: EmailSettingsEditDto;
    ldap?: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing?: TenantBillingSettingsEditDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration?: boolean;
    isNewRegisteredUserActiveByDefault?: boolean;
    isEmailConfirmationRequiredForLogin?: boolean;
    useCaptchaOnRegistration?: boolean;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration?: boolean;
    isNewRegisteredUserActiveByDefault?: boolean;
    isEmailConfirmationRequiredForLogin?: boolean;
    useCaptchaOnRegistration?: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled?: boolean;
    isEnabled?: boolean;
    domain?: string;
    userName?: string;
    password?: string;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled?: boolean;
    isEnabled?: boolean;
    domain?: string;
    userName?: string;
    password?: string;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName?: string;
    address?: string;
    taxVatNo?: string;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName?: string;
    address?: string;
    taxVatNo?: string;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items?: NameValueDto[];

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items?: NameValueDto[];
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode?: string;
    rememberClient?: boolean;
    twoFactorRememberClientToken?: string;
    singleSignIn?: boolean;
    returnUrl?: string;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode?: string;
    rememberClient?: boolean;
    twoFactorRememberClientToken?: string;
    singleSignIn?: boolean;
    returnUrl?: string;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    shouldResetPassword?: boolean;
    passwordResetCode?: string;
    userId?: number;
    requiresTwoFactorVerification?: boolean;
    twoFactorAuthProviders?: string[];
    twoFactorRememberClientToken?: string;
    returnUrl?: string;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    shouldResetPassword?: boolean;
    passwordResetCode?: string;
    userId?: number;
    requiresTwoFactorVerification?: boolean;
    twoFactorAuthProviders?: string[];
    twoFactorRememberClientToken?: string;
    returnUrl?: string;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId?: number;
    provider: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SendTwoFactorAuthCodeModel();
        result.init(json);
        return result;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId?: number;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name?: string;
    clientId?: string;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name?: string;
    clientId?: string;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl?: string;
    singleSignIn?: boolean;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl?: string;
    singleSignIn?: boolean;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    waitingForActivation?: boolean;
    returnUrl?: string;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    waitingForActivation?: boolean;
    returnUrl?: string;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout?: UiCustomizationLayoutSettingsEditDto;
    header?: UiCustomizationHeaderSettingsEditDto;
    menu?: UiCustomizationMenuSettingsEditDto;
    footer?: UiCustomizationFooterSettingsEditDto;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiCustomizationSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout?: UiCustomizationLayoutSettingsEditDto;
    header?: UiCustomizationHeaderSettingsEditDto;
    menu?: UiCustomizationMenuSettingsEditDto;
    footer?: UiCustomizationFooterSettingsEditDto;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType?: string;
    pageLoader?: string;
    contentSkin?: string;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.pageLoader = data["pageLoader"];
            this.contentSkin = data["contentSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["pageLoader"] = this.pageLoader;
        data["contentSkin"] = this.contentSkin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType?: string;
    pageLoader?: string;
    contentSkin?: string;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader?: boolean;
    desktopMinimizeMode?: string;
    mobileFixedHeader?: boolean;
    dropdownSkinDesktop?: string;
    displaySubmenuArrowDesktop?: boolean;
    dropdownSkin?: string;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.dropdownSkinDesktop = data["dropdownSkinDesktop"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
            this.dropdownSkin = data["dropdownSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["dropdownSkinDesktop"] = this.dropdownSkinDesktop;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        data["dropdownSkin"] = this.dropdownSkin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader?: boolean;
    desktopMinimizeMode?: string;
    mobileFixedHeader?: boolean;
    dropdownSkinDesktop?: string;
    displaySubmenuArrowDesktop?: boolean;
    dropdownSkin?: string;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position?: string;
    asideSkin?: string;
    fixedAside?: boolean;
    allowAsideMinimizing?: boolean;
    defaultMinimizedAside?: boolean;
    allowAsideHiding?: boolean;
    defaultHiddenAside?: boolean;
    submenuToggle?: string;
    dropdownSubmenuSkin?: string;
    dropdownSubmenuArrow?: boolean;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position?: string;
    asideSkin?: string;
    fixedAside?: boolean;
    allowAsideMinimizing?: boolean;
    defaultMinimizedAside?: boolean;
    allowAsideHiding?: boolean;
    defaultHiddenAside?: boolean;
    submenuToggle?: string;
    dropdownSubmenuSkin?: string;
    dropdownSubmenuArrow?: boolean;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter?: boolean;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    roleNames?: string[];
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    roleNames?: string[];
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    fullName?: string;
    lastLoginTime?: Date;
    creationTime?: Date;
    roleNames?: string[];
    id?: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    fullName?: string;
    lastLoginTime?: Date;
    creationTime?: Date;
    roleNames?: string[];
    id?: number;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items?: RoleDto[];

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items?: RoleDto[];
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount?: number;
    items?: UserDto[];

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount?: number;
    items?: UserDto[];
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount?: number;
    items?: UserListDto[];

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount?: number;
    items?: UserListDto[];
}

export class UserListDto implements IUserListDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    phoneNumber?: string;
    profilePictureId?: string;
    isEmailConfirmed?: boolean;
    roles?: UserListRoleDto[];
    lastLoginTime?: Date;
    isActive?: boolean;
    creationTime?: Date;
    id?: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

export interface IUserListDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    phoneNumber?: string;
    profilePictureId?: string;
    isEmailConfirmed?: boolean;
    roles?: UserListRoleDto[];
    lastLoginTime?: Date;
    isActive?: boolean;
    creationTime?: Date;
    id?: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId?: number;
    roleName?: string;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId?: number;
    roleName?: string;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId?: string;
    user?: UserEditDto;
    roles?: UserRoleDto[];
    allOrganizationUnits?: OrganizationUnitDto[];
    memberedOrganizationUnits?: string[];

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId?: string;
    user?: UserEditDto;
    roles?: UserRoleDto[];
    allOrganizationUnits?: OrganizationUnitDto[];
    memberedOrganizationUnits?: string[];
}

export class UserEditDto implements IUserEditDto {
    id?: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber?: string;
    password?: string;
    isActive?: boolean;
    shouldChangePasswordOnNextLogin?: boolean;
    isTwoFactorEnabled?: boolean;
    isLockoutEnabled?: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    id?: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber?: string;
    password?: string;
    isActive?: boolean;
    shouldChangePasswordOnNextLogin?: boolean;
    isTwoFactorEnabled?: boolean;
    isLockoutEnabled?: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    roleId?: number;
    roleName?: string;
    roleDisplayName?: string;
    isAssigned?: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId?: number;
    roleName?: string;
    roleDisplayName?: string;
    isAssigned?: boolean;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions?: FlatPermissionDto[];
    grantedPermissionNames?: string[];

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions?: FlatPermissionDto[];
    grantedPermissionNames?: string[];
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id?: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id?: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id?: number;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id?: number;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail?: boolean;
    setRandomPassword?: boolean;
    organizationUnits?: number[];

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail?: boolean;
    setRandomPassword?: boolean;
    organizationUnits?: number[];
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName?: string;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName?: string;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount?: number;
    items?: LinkedUserDto[];

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount?: number;
    items?: LinkedUserDto[];
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId?: number;
    tenancyName?: string;
    username?: string;
    lastLoginTime?: Date;
    id?: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId?: number;
    tenancyName?: string;
    username?: string;
    lastLoginTime?: Date;
    id?: number;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items?: LinkedUserDto[];

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items?: LinkedUserDto[];
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId?: number;
    userId?: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId?: number;
    userId?: number;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items?: UserLoginAttemptDto[];

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items?: UserLoginAttemptDto[];
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName?: string;
    userNameOrEmail?: string;
    clientIpAddress?: string;
    clientName?: string;
    browserInfo?: string;
    result?: string;
    creationTime?: Date;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName?: string;
    userNameOrEmail?: string;
    clientIpAddress?: string;
    clientName?: string;
    browserInfo?: string;
    result?: string;
    creationTime?: Date;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines?: string[];

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines?: string[];
}

export class WorkCreateInput implements IWorkCreateInput {
    subject: string;
    body: string;
    urgency?: WorkCreateInputUrgency;
    relatedWorkId?: number;
    tagId?: number;
    customerId?: number;
    timeLimit?: number;
    receiverId?: number;
    organizationUnitId?: number;

    constructor(data?: IWorkCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.body = data["body"];
            this.urgency = data["urgency"];
            this.relatedWorkId = data["relatedWorkId"];
            this.tagId = data["tagId"];
            this.customerId = data["customerId"];
            this.timeLimit = data["timeLimit"];
            this.receiverId = data["receiverId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): WorkCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new WorkCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["urgency"] = this.urgency;
        data["relatedWorkId"] = this.relatedWorkId;
        data["tagId"] = this.tagId;
        data["customerId"] = this.customerId;
        data["timeLimit"] = this.timeLimit;
        data["receiverId"] = this.receiverId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WorkCreateInput();
        result.init(json);
        return result;
    }
}

export interface IWorkCreateInput {
    subject: string;
    body: string;
    urgency?: WorkCreateInputUrgency;
    relatedWorkId?: number;
    tagId?: number;
    customerId?: number;
    timeLimit?: number;
    receiverId?: number;
    organizationUnitId?: number;
}

export class FinishStepInput implements IFinishStepInput {
    workId?: number;
    stepId?: number;
    result: string;
    receiverId: number;

    constructor(data?: IFinishStepInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workId = data["workId"];
            this.stepId = data["stepId"];
            this.result = data["result"];
            this.receiverId = data["receiverId"];
        }
    }

    static fromJS(data: any): FinishStepInput {
        data = typeof data === 'object' ? data : {};
        let result = new FinishStepInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workId"] = this.workId;
        data["stepId"] = this.stepId;
        data["result"] = this.result;
        data["receiverId"] = this.receiverId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FinishStepInput();
        result.init(json);
        return result;
    }
}

export interface IFinishStepInput {
    workId?: number;
    stepId?: number;
    result: string;
    receiverId: number;
}

export enum IncomeStatisticsDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum State {
    _0 = 0, 
    _1 = 1, 
}

export enum SalesSummaryDatePeriod {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum SalesSummaryDatePeriod2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum DefaultTimezoneScope {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum FriendDtoState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReceiverReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export enum TenantNotificationSeverity {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class AdditionalData implements IAdditionalData {
    paypal?: { [key: string] : string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AdditionalData();
        result.init(json);
        return result;
    }
}

export interface IAdditionalData {
    paypal?: { [key: string] : string; };
}

export enum CreatePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreatePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CreatePaymentDtoSubscriptionPaymentGatewayType {
    _1 = 1, 
}

export enum ExecutePaymentDtoGateway {
    _1 = 1, 
}

export enum ExecutePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ExecutePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum TenantLoginInfoDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum RegisterTenantInputSubscriptionStartType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterTenantInputGateway {
    _1 = 1, 
}

export enum WorkCreateInputUrgency {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}